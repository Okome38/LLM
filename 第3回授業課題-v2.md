# 第 3 回授業課題

## 学習支援オントロジー強化 RAG システムの構築

**所要時間**: 180 分

**成果物の提出先**: GitHub リポジトリ

---

## 今日の学習目標

1. **知識ベース**と**オントロジー**の概念を理解する
2. **オントロジーと構造化 RAG の違い**を理解する
3. **学習支援に特化したオントロジー**を設計・実装する
4. **ハイブリッド検索**（ベクトル検索 + BM25）で精度の高い検索を実現する
5. **第 2 回で作成したテスト対策 RAG**を今回の技術で改善する

**完成するもの**: 学習者の理解度に応じて適応的に支援する RAG システム

---

## 今日の成果物チェックリスト

### **必須項目**

- [ ] 知識ベース・オントロジーの概念を理解し、説明できる
- [ ] オントロジーと構造化 RAG の違いを説明できる
- [ ] `LearningOntology`クラスを実装（前提知識チェーン、難易度対応）
- [ ] `ConceptExtractor`クラスを実装
- [ ] `LearningSupport`クラスを実装（ヒント生成、難易度適応）
- [ ] `HybridSearchEngine`クラスを実装（ベクトル + BM25）
- [ ] 学習進捗 UI を実装
- [ ] テストを実施
- [ ] GitHub にコミット・プッシュ

### **発展項目（時間が余った場合）**

- [ ] 第 2 回のテスト対策 RAG をオントロジーで強化
- [ ] 自分の教科書に合わせたオントロジーを設計
- [ ] 学習履歴の永続化（localStorage）

---

## 推奨タイムスケジュール

| 時間           | 内容                                         |
| -------------- | -------------------------------------------- |
| **0-50 分**    | STEP 0-1: 知識ベース・オントロジーの理論理解 |
| **50-80 分**   | STEP 2-3: オントロジー実装                   |
| **80-110 分**  | STEP 4: 学習支援機能の実装                   |
| **110-140 分** | STEP 5: ハイブリッド検索の実装               |
| **140-160 分** | STEP 6-7: UI 実装・テスト                    |
| **160-180 分** | STEP 8: テスト対策 RAG の改善・提出          |

---

## STEP 0: 知識ベースとオントロジーの理論理解（30 分）

### **0-1. 知識ベースとは？**

**定義**: コンピュータが利用できる形式で整理された知識の集まり

```
【日常の例】
・辞書：言葉の意味を体系的にまとめたもの
・百科事典：さまざまな知識を分類・整理したもの
・教科書の索引：概念と説明箇所を対応付けたもの

【コンピュータの知識ベース】
・事実（Fact）：「東京は日本の首都である」
・ルール（Rule）：「首都には政府機関がある」
・関係（Relation）：「東京 → is-capital-of → 日本」
```

**なぜ RAG に知識ベースが必要？**

| LLM 単体             | LLM + 知識ベース           |
| -------------------- | -------------------------- |
| 学習時の知識のみ     | 最新・専門知識を追加可能   |
| 知識の根拠が不明     | 出典を明示できる           |
| 知識の更新が困難     | データ追加で簡単に更新     |
| 関連知識の探索が苦手 | 構造化された知識で探索可能 |

---

### **0-2. オントロジーとは？**

**定義**: 概念（モノや事柄）とその関係性を形式的に定義したもの

```
【語源】
ギリシャ語の「存在論」から
・onto = 存在するもの
・logos = 学問、論理

【情報科学での意味】
「ある領域（ドメイン）の概念と、概念間の関係を明示的に定義したもの」
```

**オントロジーの構成要素**

```
┌─────────────────────────────────────────────────────────┐
│ オントロジーの4つの構成要素                               │
├─────────────────────────────────────────────────────────┤
│ 1. クラス（Class）                                       │
│    → 概念のカテゴリ                                      │
│    例：「プログラミング言語」「データ構造」                  │
│                                                         │
│ 2. インスタンス（Instance）                               │
│    → クラスの具体例                                      │
│    例：「Python」は「プログラミング言語」のインスタンス       │
│                                                         │
│ 3. プロパティ（Property）                                 │
│    → 概念の属性                                          │
│    例：難易度、説明文、前提知識                            │
│                                                         │
│ 4. 関係（Relation）                                      │
│    → 概念間のつながり                                    │
│    例：「is-a」「prerequisite-of」「related-to」          │
└─────────────────────────────────────────────────────────┘
```

---

### **0-3. 具体例：プログラミング学習のオントロジー**

```
                    ┌──────────────┐
                    │プログラミング │
                    │   (基礎)     │
                    └──────┬───────┘
                           │ contains（含む）
           ┌───────────────┼───────────────┐
           ▼               ▼               ▼
    ┌──────────┐    ┌──────────┐    ┌──────────┐
    │  変数    │    │  関数    │    │  ループ  │
    │(beginner)│    │(intermed)│    │(beginner)│
    └────┬─────┘    └────┬─────┘    └────┬─────┘
         │               │               │
         │ prerequisite  │               │
         └───────────────┘               │
                         │ prerequisite  │
                         └───────────────┘

【関係の種類】
• prerequisite（前提知識）: 変数 → 関数（変数を知らないと関数は理解できない）
• contains（含む）: プログラミング → 変数、関数、ループ
• related-to（関連）: ループ ↔ 配列（よく一緒に使う）
```

---

### **0-4. オントロジー vs 知識グラフ vs 構造化 RAG**

この 3 つはよく混同されますが、**役割が違います**：

```
┌────────────────────────────────────────────────────────────────┐
│                        役割の違い                              │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  オントロジー        知識グラフ         構造化RAG              │
│  （設計図）     →   （実データ）    →  （活用方法）            │
│                                                                │
│  「概念Aと概念Bは     「Python は        「質問に関連する       │
│   こういう関係」      プログラミング      ノードを探して         │
│   という定義          言語である」        LLMに渡す」            │
│                       という事実          という仕組み           │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

| 観点         | オントロジー         | 知識グラフ             | 構造化 RAG             |
| ------------ | -------------------- | ---------------------- | ---------------------- |
| **役割**     | 概念・関係の**定義** | 具体的な**事実の蓄積** | データの**検索・活用** |
| **例えると** | 辞書の「編集方針」   | 辞書の「中身」         | 辞書を「引く仕組み」   |
| **作成者**   | ドメイン専門家       | データエンジニア       | システム開発者         |
| **変更頻度** | まれ（構造は安定）   | 頻繁（新事実追加）     | システム更新時         |

---

### **0-5. ⭐ なぜオントロジーが重要なのか？（核心）**

**オントロジーなしの RAG（第 2 回で作ったもの）の問題点：**

```
【問題1: 同義語・類義語を理解できない】

質問：「繰り返し処理について教えて」
文書：「forループは...」「whileループは...」

→ 「繰り返し」と「ループ」が同じ意味だと分からない
→ 関連文書を見逃す
```

```
【問題2: 概念間の関係を知らない】

質問：「再帰関数を教えて」

→ 「再帰」には「関数」の理解が前提だと分からない
→ 学習者が「関数」を知らなくても気づかない
→ 理解できない説明をしてしまう
```

```
【問題3: 関連知識を提示できない】

質問：「配列について」

→ 「ループ」や「インデックス」が関連すると分からない
→ 学習を広げる提案ができない
```

**オントロジーがある RAG の解決策：**

```
【解決1: 同義語の展開】

オントロジー定義：
  loops:
    label: "ループ"
    synonyms: ["繰り返し", "反復", "イテレーション"]

質問：「繰り返し処理について教えて」
  ↓ オントロジー参照
「繰り返し」→「ループ」の別名と認識
  ↓
拡張クエリ：「繰り返し ループ for while」
  ↓
検索精度向上！
```

```
【解決2: 前提知識のチェック】

オントロジー定義：
  recursion:
    prerequisites: ["functions"]
  functions:
    prerequisites: ["variables"]

質問：「再帰について教えて」
  ↓ オントロジー参照
前提知識チェーン：再帰 ← 関数 ← 変数
  ↓
「関数は理解していますか？」と確認
または
「再帰を理解するには、まず関数を学びましょう」と案内
  ↓
学習者に適した説明！
```

```
【解決3: 関連知識の提示】

オントロジー定義：
  arrays:
    relatedConcepts: ["loops", "index"]

質問：「配列について」
  ↓ オントロジー参照
関連概念：ループ、インデックス
  ↓
「配列を学んだら、次はループと組み合わせて使ってみましょう」
  ↓
学習の広がり！
```

---

### **0-6. オントロジーの価値：3 つのレイヤー**

```
┌─────────────────────────────────────────────────────────────┐
│           オントロジーがもたらす3つの価値                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  【レイヤー1: 語彙の統一】                                   │
│   同じ概念の異なる表現を結びつける                           │
│   例：「ループ」=「繰り返し」=「反復」                        │
│   効果：検索漏れの防止                                       │
│                                                             │
│  【レイヤー2: 構造の定義】                                   │
│   概念間の関係を明示する                                     │
│   例：変数 → 関数 → 再帰（前提知識の連鎖）                   │
│   効果：学習順序の最適化、理解度チェック                      │
│                                                             │
│  【レイヤー3: 知識の付加】                                   │
│   概念に追加情報を紐づける                                   │
│   例：難易度別説明、よくある誤解、練習問題                    │
│   効果：適応的な学習支援                                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

### **0-7. 今日作るシステムの全体像**

```
┌─────────────────────────────────────────────────────────────┐
│              学習支援オントロジーRAGシステム                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              オントロジー（STEP 3）                  │   │
│  │  ・概念の定義（変数、関数、ループ...）                │   │
│  │  ・関係の定義（prerequisite, related）               │   │
│  │  ・同義語の定義                                      │   │
│  │  ・難易度別説明                                      │   │
│  │  ・よくある誤解                                      │   │
│  │  ・練習問題                                          │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓ を使って                         │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              学習支援機能（STEP 4）                  │   │
│  │  ・前提知識チェック                                  │   │
│  │  ・難易度適応型説明                                  │   │
│  │  ・段階的ヒント生成                                  │   │
│  │  ・学習パス生成                                      │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓ と組み合わせて                    │
│  ┌─────────────────────────────────────────────────────┐   │
│  │            ハイブリッド検索（STEP 5）                │   │
│  │  ・ベクトル検索（意味的類似）                        │   │
│  │  ・BM25検索（キーワード一致）                        │   │
│  │  ・オントロジーによるクエリ拡張                      │   │
│  │  ・オントロジーによるリランキング                    │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓ 結果を                           │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                    LLM                              │   │
│  │  ・学習者レベルに応じた回答生成                      │   │
│  │  ・よくある誤解への注意喚起                          │   │
│  │  ・次の学習ステップの提案                            │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

### **0-8. 第 2 回の復習確認**

**前回作ったファイルを確認：**

- [ ] `js/vector-search.js` が存在
- [ ] `js/rag-system.js` が存在
- [ ] `data/sample-documents.json` に文書がある
- [ ] 第 2 回の RAG が動作する

**もし動かない場合**: まず第 2 回の実装を完成させてから進んでください

---

## STEP 1: 学習支援オントロジーの設計（20 分）

### **1-1. 学習支援に特化したオントロジーの 4 つの要素**

通常のオントロジーに、学習支援のための要素を追加します：

| 要素                   | 説明                                     | 例                             |
| ---------------------- | ---------------------------------------- | ------------------------------ |
| **前提知識チェーン**   | この概念を理解するために必要な知識の連鎖 | 再帰 → 関数 → 変数             |
| **難易度レベル別説明** | 学習者のレベルに応じた説明               | beginner/intermediate/advanced |
| **よくある誤解**       | 学習者が陥りやすい間違いと正しい理解     | 「変数は箱」→「変数はラベル」  |
| **練習問題**           | 理解度確認用の問題と段階的ヒント         | Q + ヒント 1 + ヒント 2 + 答え |

### **1-2. 設計例：「変数」の概念**

```
概念ID: "variables"
├── 基本情報
│   ├── ラベル: 「変数」
│   ├── レベル: beginner
│   ├── 同義語: ["var", "変数宣言"]
│   └── 説明: 「データを格納するための名前付きの場所」
│
├── 前提知識: なし（基礎概念）
│
├── 難易度別説明
│   ├── beginner: 「名前をつけてデータを保存する仕組みです」
│   ├── intermediate: 「メモリ上の領域を参照する識別子です」
│   └── advanced: 「スコープとライフタイムを持つ束縛です」
│
├── よくある誤解
│   ├── 誤解1:
│   │   ├── 間違い: 「変数は箱のようなもの」
│   │   ├── 正解: 「変数はラベル（参照）」
│   │   └── ヒント: 「let a=[1,2]; let b=a; でbを変えるとaも変わる」
│   │
│   └── 誤解2:
│       ├── 間違い: 「= は等しいという意味」
│       ├── 正解: 「= は代入（右を左に入れる）」
│       └── ヒント: 「x = x + 1 は数学では矛盾するが、プログラミングでは有効」
│
├── 練習問題
│   ├── Q1: 「let x = 5; の後、xの値は？」
│   │   ├── ヒント1: 「letは変数宣言のキーワード」
│   │   ├── ヒント2: 「=の右側が左側に入る」
│   │   └── 答え: 「5」
│   │
│   └── Q2: 「let a=10; let b=a; a=20; このときbは？」
│       ├── ヒント1: 「代入時点の値がコピーされる」
│       └── 答え: 「10」
│
└── 関連概念: データ型、スコープ、メモリ
```

---

## STEP 2: プロジェクト構造の準備

### **2-1. 新規ファイル作成**

VS Code で以下のファイルを作成：

```
llm-rag-learning-template/
├── js/
│   ├── llm-client.js           ✅ 既存（第1回）
│   ├── vector-search.js        ✅ 既存（第2回）
│   ├── rag-system.js           ✅ 既存（第2回）
│   ├── ontology.js             ⭐ 新規作成
│   ├── concept-extractor.js    ⭐ 新規作成
│   ├── learning-support.js     ⭐ 新規作成（学習支援機能）
│   ├── hybrid-search.js        ⭐ 新規作成（ハイブリッド検索）
│   ├── semantic-rag.js         ⭐ 新規作成
│   └── app-learning.js         ⭐ 新規作成
├── data/
│   ├── sample-documents.json   ✅ 既存
│   └── learning-ontology.json  ⭐ 新規作成
└── learning-rag.html           ⭐ 新規作成
```

---

## STEP 3: 学習支援オントロジーの実装

### **3-1. learning-ontology.json を作成**

`data/learning-ontology.json` を新規作成：

```json
{
  "concepts": {
    "programming": {
      "label": "プログラミング",
      "level": "beginner",
      "subConcepts": ["variables", "functions", "loops", "conditionals"],
      "prerequisites": [],
      "relatedConcepts": ["computer-science", "algorithms"],
      "synonyms": ["コーディング", "プログラム作成"],
      "description": "コンピュータプログラムの作成技術",
      "explanations": {
        "beginner": "コンピュータに「こうして」と指示を出す方法です。料理のレシピのように、順番に手順を書いていきます。",
        "intermediate": "コンピュータが理解できる言語を使って、処理手順（アルゴリズム）を記述する技術です。",
        "advanced": "計算モデルに基づく形式言語を用いて、チューリング完全な計算を記述する行為です。"
      },
      "misconceptions": [
        {
          "wrong": "プログラミングは数学ができないとできない",
          "correct": "基本的な論理的思考があれば始められます。高度な数学が必要になるのは特定の分野だけです。",
          "hint": "まずは簡単なプログラムから始めて、必要に応じて数学を学びましょう。"
        }
      ],
      "exercises": [
        {
          "id": "prog-ex1",
          "question": "プログラムとは何を記述したものですか？",
          "type": "multiple-choice",
          "options": ["コンピュータへの指示", "数学の公式", "日本語の文章"],
          "answer": 0,
          "hints": [
            "料理のレシピを思い出してください",
            "コンピュータに「何をしてほしいか」を伝えます"
          ]
        }
      ]
    },
    "variables": {
      "label": "変数",
      "level": "beginner",
      "subConcepts": ["data-types", "scope"],
      "prerequisites": [],
      "relatedConcepts": ["memory", "assignment"],
      "synonyms": ["var", "変数宣言", "variable"],
      "description": "データを格納するための名前付きの場所",
      "explanations": {
        "beginner": "名前をつけてデータを保存する仕組みです。「x = 5」と書くと、「x」という名前で「5」を覚えておけます。",
        "intermediate": "メモリ上の領域を参照するための識別子です。値を格納し、プログラム中で再利用できます。",
        "advanced": "スコープとライフタイムを持つ束縛（binding）であり、環境（environment）内で識別子と値を対応付けます。"
      },
      "misconceptions": [
        {
          "wrong": "変数は「箱」のようなもの",
          "correct": "変数は「ラベル」や「名札」に近いです。特にJavaScriptでは、変数は値への参照（ポインタ）です。",
          "hint": "let a = [1,2,3]; let b = a; のとき、bを変更するとaも変わります。箱なら別々のはずですよね？"
        },
        {
          "wrong": "「=」は「等しい」という意味",
          "correct": "プログラミングの「=」は「代入」（右辺の値を左辺に入れる）です。等しいかの比較は「==」や「===」を使います。",
          "hint": "x = x + 1 は数学では矛盾しますが、プログラミングでは「xに1を足す」という意味です。"
        }
      ],
      "exercises": [
        {
          "id": "var-ex1",
          "question": "let x = 5; の後、x の値は？",
          "type": "short-answer",
          "answer": "5",
          "hints": [
            "letは変数を宣言するキーワードです",
            "=の右側の値が左側の変数に入ります"
          ]
        },
        {
          "id": "var-ex2",
          "question": "let a = 10; let b = a; a = 20; このとき b の値は？",
          "type": "short-answer",
          "answer": "10",
          "hints": [
            "代入した時点の値がコピーされます（数値の場合）",
            "aを後で変えても、bには影響しません"
          ]
        }
      ]
    },
    "functions": {
      "label": "関数",
      "level": "intermediate",
      "subConcepts": ["parameters", "return-values", "recursion"],
      "prerequisites": ["variables"],
      "relatedConcepts": ["procedures", "methods", "abstraction"],
      "synonyms": ["function", "メソッド", "サブルーチン", "手続き"],
      "description": "再利用可能なコードブロック",
      "explanations": {
        "beginner": "何度も使う処理をまとめて名前をつけたものです。「挨拶する」という関数を作れば、何度でも使えます。",
        "intermediate": "入力（引数）を受け取り、処理を行い、出力（戻り値）を返す再利用可能なコードの単位です。",
        "advanced": "ファーストクラスオブジェクトとして扱われ、クロージャを形成し、高階関数のパラメータや戻り値となりえます。"
      },
      "misconceptions": [
        {
          "wrong": "関数は必ず値を返す",
          "correct": "値を返さない関数（副作用のみの関数）もあります。console.log()は画面に表示するだけで、意味のある値は返しません。",
          "hint": "関数には「何かを計算して結果を返す」ものと「何かの動作をする」ものがあります。"
        },
        {
          "wrong": "関数の中で宣言した変数は外からも使える",
          "correct": "関数内で宣言した変数は関数の外からは見えません（ローカルスコープ）。",
          "hint": "これは「スコープ」という概念です。変数には「見える範囲」があります。"
        }
      ],
      "exercises": [
        {
          "id": "func-ex1",
          "question": "function add(a, b) { return a + b; } add(3, 4)の結果は？",
          "type": "short-answer",
          "answer": "7",
          "hints": ["a=3, b=4として計算します", "returnは結果を返します"]
        }
      ]
    },
    "loops": {
      "label": "ループ",
      "level": "beginner",
      "subConcepts": ["for-loop", "while-loop", "iteration"],
      "prerequisites": ["variables"],
      "relatedConcepts": ["conditionals", "arrays"],
      "synonyms": ["繰り返し", "反復", "イテレーション", "ループ処理"],
      "description": "同じ処理を繰り返し実行する構造",
      "explanations": {
        "beginner": "同じことを何度も繰り返したいときに使います。「10回『こんにちは』と言う」のような処理です。",
        "intermediate": "条件が満たされている間、または指定回数だけ処理を反復実行する制御構造です。",
        "advanced": "反復子パターンを抽象化した構造で、イテレータプロトコルに基づく遅延評価が可能です。"
      },
      "misconceptions": [
        {
          "wrong": "forループとwhileループは同じ",
          "correct": "forは回数が決まっているとき、whileは条件が満たされている間、という使い分けが一般的です。",
          "hint": "「10回繰り返す」→ for、「正解するまで繰り返す」→ while"
        },
        {
          "wrong": "無限ループは必ずバグ",
          "correct": "サーバーやゲームのメインループなど、意図的な無限ループもあります。",
          "hint": "ただし、意図しない無限ループはバグです。終了条件を必ず確認しましょう。"
        }
      ],
      "exercises": [
        {
          "id": "loop-ex1",
          "question": "for(let i=0; i<3; i++) { console.log(i); } 何が表示される？",
          "type": "short-answer",
          "answer": "0, 1, 2",
          "hints": [
            "i=0から始まります",
            "i<3の間繰り返すので、i=3では止まります"
          ]
        }
      ]
    },
    "data-structures": {
      "label": "データ構造",
      "level": "intermediate",
      "subConcepts": ["arrays", "objects", "linked-lists"],
      "prerequisites": ["variables", "loops"],
      "relatedConcepts": ["algorithms", "complexity"],
      "synonyms": ["配列", "リスト", "コレクション"],
      "description": "データを効率的に格納・操作する方法",
      "explanations": {
        "beginner": "たくさんのデータを整理して保存する方法です。本棚のように順番に並べたり、辞書のように名前をつけて保存したりします。",
        "intermediate": "データの格納方法と、それに対する操作（追加・削除・検索など）の効率を考慮した構造です。",
        "advanced": "計算量（時間・空間）のトレードオフを考慮し、問題の性質に応じた最適な抽象データ型を選択します。"
      },
      "misconceptions": [
        {
          "wrong": "配列は何でも入れられる万能な構造",
          "correct": "配列は順序付きのデータには向いていますが、キーで検索したい場合はオブジェクト/Mapが適しています。",
          "hint": "「番号で取り出す」→配列、「名前で取り出す」→オブジェクト"
        }
      ],
      "exercises": [
        {
          "id": "ds-ex1",
          "question": "let arr = [10, 20, 30]; arr[1]の値は？",
          "type": "short-answer",
          "answer": "20",
          "hints": [
            "配列のインデックスは0から始まります",
            "arr[0]=10, arr[1]=20, arr[2]=30"
          ]
        }
      ]
    },
    "algorithms": {
      "label": "アルゴリズム",
      "level": "intermediate",
      "subConcepts": ["sorting", "searching", "recursion"],
      "prerequisites": ["functions", "loops", "data-structures"],
      "relatedConcepts": ["complexity", "optimization"],
      "synonyms": ["計算手法", "処理手順", "解法"],
      "description": "問題解決の手順",
      "explanations": {
        "beginner": "問題を解くための手順・レシピです。「一番大きい数を見つける」にも決まった手順があります。",
        "intermediate": "入力から出力を得るための有限の手順で、正確性・効率性・停止性が保証されます。",
        "advanced": "計算複雑性理論に基づき、問題クラス（P, NP等）と計算量のオーダーで分類・評価されます。"
      },
      "misconceptions": [
        {
          "wrong": "アルゴリズムは難しい数学の問題",
          "correct": "日常的な問題解決も立派なアルゴリズムです。例えば「辞書で言葉を探す」にもアルゴリズムがあります。",
          "hint": "二分探索：辞書の真ん中を開いて、探す言葉が前半か後半かを判断する、を繰り返す"
        }
      ],
      "exercises": [
        {
          "id": "algo-ex1",
          "question": "[3, 1, 4, 1, 5]から最大値を見つけるアルゴリズムの基本的な考え方は？",
          "type": "multiple-choice",
          "options": [
            "全部足す",
            "最初の要素を仮の最大値とし、順に比較して更新",
            "ランダムに選ぶ"
          ],
          "answer": 1,
          "hints": [
            "一つずつ見ていく必要があります",
            "今までで一番大きい数を覚えておきます"
          ]
        }
      ]
    }
  },
  "relations": [
    {
      "from": "variables",
      "to": "functions",
      "type": "prerequisite",
      "strength": 0.9
    },
    {
      "from": "variables",
      "to": "loops",
      "type": "prerequisite",
      "strength": 0.8
    },
    {
      "from": "variables",
      "to": "data-structures",
      "type": "prerequisite",
      "strength": 0.7
    },
    {
      "from": "loops",
      "to": "data-structures",
      "type": "prerequisite",
      "strength": 0.6
    },
    {
      "from": "functions",
      "to": "algorithms",
      "type": "prerequisite",
      "strength": 0.8
    },
    {
      "from": "loops",
      "to": "algorithms",
      "type": "prerequisite",
      "strength": 0.8
    },
    {
      "from": "data-structures",
      "to": "algorithms",
      "type": "prerequisite",
      "strength": 0.9
    },
    {
      "from": "functions",
      "to": "recursion",
      "type": "prerequisite",
      "strength": 0.9
    },
    {
      "from": "algorithms",
      "to": "data-structures",
      "type": "related",
      "strength": 0.9
    },
    { "from": "loops", "to": "arrays", "type": "related", "strength": 0.8 }
  ],
  "learnerLevels": {
    "beginner": {
      "description": "プログラミング初学者",
      "characteristics": [
        "具体的な例で理解",
        "比喩を好む",
        "一度に多くの情報は難しい"
      ]
    },
    "intermediate": {
      "description": "基礎を理解し応用段階",
      "characteristics": [
        "抽象的な概念も理解可能",
        "技術用語を使える",
        "複数概念の関連付けができる"
      ]
    },
    "advanced": {
      "description": "深い理解を持つ学習者",
      "characteristics": [
        "理論的背景に興味",
        "最適化を考慮",
        "設計判断ができる"
      ]
    }
  }
}
```

### **3-2. ontology.js を作成**

`js/ontology.js` を新規作成：

```javascript
// js/ontology.js - 学習支援オントロジーの管理

class LearningOntology {
  constructor() {
    this.concepts = new Map();
    this.relations = new Map();
    this.learnerLevels = {};
  }

  // オントロジーデータの読み込み
  async loadOntology(ontologyData) {
    console.log("📚 学習支援オントロジーを読み込み中...");

    // 概念の追加
    for (const [conceptId, conceptData] of Object.entries(
      ontologyData.concepts
    )) {
      this.addConcept(conceptId, conceptData);
    }

    // 関係の追加
    for (const relation of ontologyData.relations) {
      this.addRelation(
        relation.from,
        relation.to,
        relation.type,
        relation.strength || 1.0
      );
    }

    // 学習者レベル定義の読み込み
    if (ontologyData.learnerLevels) {
      this.learnerLevels = ontologyData.learnerLevels;
    }

    console.log(`✅ ${this.concepts.size}個の概念を読み込みました`);
    console.log(`✅ ${this.relations.size}個の関係を読み込みました`);
  }

  // 概念の追加
  addConcept(id, properties) {
    this.concepts.set(id, {
      id: id,
      ...properties,
      addedAt: new Date(),
    });
  }

  // 関係の追加
  addRelation(fromConcept, toConcept, relationType, strength = 1.0) {
    const relationKey = `${fromConcept}-${relationType}-${toConcept}`;
    this.relations.set(relationKey, {
      from: fromConcept,
      to: toConcept,
      type: relationType,
      strength: strength,
    });
  }

  // 概念の取得
  getConcept(conceptId) {
    return this.concepts.get(conceptId);
  }

  // ⭐ 前提知識チェーンの取得（学習支援の核心機能）
  getPrerequisiteChain(conceptId, visited = new Set()) {
    if (visited.has(conceptId)) return [];
    visited.add(conceptId);

    const chain = [];
    const concept = this.concepts.get(conceptId);

    if (concept && concept.prerequisites) {
      for (const prereq of concept.prerequisites) {
        chain.push({
          conceptId: prereq,
          concept: this.concepts.get(prereq),
          depth: 1,
        });
        const subChain = this.getPrerequisiteChain(prereq, visited);
        subChain.forEach((item) => {
          item.depth += 1;
          chain.push(item);
        });
      }
    }

    return chain.sort((a, b) => b.depth - a.depth);
  }

  // ⭐ 難易度に応じた説明の取得
  getExplanation(conceptId, level = "beginner") {
    const concept = this.concepts.get(conceptId);
    if (!concept) return null;

    if (concept.explanations && concept.explanations[level]) {
      return {
        level: level,
        text: concept.explanations[level],
        concept: concept,
      };
    }

    return {
      level: "default",
      text: concept.description,
      concept: concept,
    };
  }

  // ⭐ よくある誤解の取得
  getMisconceptions(conceptId) {
    const concept = this.concepts.get(conceptId);
    if (!concept || !concept.misconceptions) return [];

    return concept.misconceptions.map((m, index) => ({
      id: `${conceptId}-misconception-${index}`,
      ...m,
    }));
  }

  // ⭐ 練習問題の取得
  getExercises(conceptId) {
    const concept = this.concepts.get(conceptId);
    if (!concept || !concept.exercises) return [];
    return concept.exercises;
  }

  // ⭐ 段階的ヒントの取得
  getHint(exerciseId, hintLevel = 0) {
    for (const [conceptId, concept] of this.concepts) {
      if (concept.exercises) {
        const exercise = concept.exercises.find((ex) => ex.id === exerciseId);
        if (exercise && exercise.hints && exercise.hints[hintLevel]) {
          return {
            hint: exercise.hints[hintLevel],
            currentLevel: hintLevel,
            totalHints: exercise.hints.length,
            hasMoreHints: hintLevel < exercise.hints.length - 1,
          };
        }
      }
    }
    return null;
  }

  // ⭐ 同義語・別名の取得（クエリ拡張用）
  getSynonyms(conceptId) {
    const concept = this.concepts.get(conceptId);
    if (!concept) return [];

    const synonyms = [concept.label];
    if (concept.synonyms) {
      synonyms.push(...concept.synonyms);
    }
    return synonyms;
  }

  // 関連概念の探索
  findRelatedConcepts(conceptId, maxDepth = 2) {
    const visited = new Set();
    const related = new Set();
    const queue = [{ concept: conceptId, depth: 0 }];

    while (queue.length > 0) {
      const { concept, depth } = queue.shift();
      if (visited.has(concept) || depth > maxDepth) continue;
      visited.add(concept);
      if (depth > 0) related.add(concept);

      for (const [key, relation] of this.relations) {
        if (relation.from === concept && !visited.has(relation.to)) {
          queue.push({ concept: relation.to, depth: depth + 1 });
        }
        if (relation.to === concept && !visited.has(relation.from)) {
          queue.push({ concept: relation.from, depth: depth + 1 });
        }
      }
    }

    return Array.from(related);
  }

  // 全概念のリスト取得
  getAllConcepts() {
    return Array.from(this.concepts.entries()).map(([id, data]) => ({
      id,
      ...data,
    }));
  }

  // デバッグ用
  printOntology() {
    console.log("=== 学習支援オントロジーの状態 ===");
    console.log("概念数:", this.concepts.size);
    console.log("関係数:", this.relations.size);

    console.log("\n概念一覧:");
    for (const [id, concept] of this.concepts) {
      const prereqs = concept.prerequisites?.join(", ") || "なし";
      const synonyms = concept.synonyms?.join(", ") || "なし";
      console.log(`- ${id}: ${concept.label}`);
      console.log(`  前提知識: ${prereqs}, 同義語: ${synonyms}`);
    }
  }
}
```

### **3-3. concept-extractor.js を作成**

`js/concept-extractor.js` を新規作成：

```javascript
// js/concept-extractor.js - 文章から概念を抽出

class ConceptExtractor {
  constructor() {
    this.conceptKeywords = new Map([
      [
        "programming",
        ["プログラミング", "プログラム", "コーディング", "coding", "コード"],
      ],
      ["variables", ["変数", "variable", "var", "let", "const", "代入"]],
      [
        "functions",
        ["関数", "function", "メソッド", "method", "引数", "戻り値", "return"],
      ],
      [
        "loops",
        [
          "ループ",
          "for",
          "while",
          "繰り返し",
          "iteration",
          "反復",
          "イテレーション",
        ],
      ],
      [
        "conditionals",
        ["条件分岐", "if", "else", "条件", "conditional", "switch"],
      ],
      [
        "data-structures",
        [
          "データ構造",
          "data structure",
          "配列",
          "array",
          "オブジェクト",
          "object",
          "リスト",
        ],
      ],
      [
        "algorithms",
        ["アルゴリズム", "algorithm", "計算手法", "ソート", "探索", "検索"],
      ],
      ["recursion", ["再帰", "recursion", "再帰的", "再帰関数"]],
    ]);
  }

  extractConcepts(text) {
    const concepts = [];
    const lowerText = text.toLowerCase();

    for (const [concept, keywords] of this.conceptKeywords) {
      for (const keyword of keywords) {
        if (lowerText.includes(keyword.toLowerCase())) {
          concepts.push(concept);
          break;
        }
      }
    }

    return [...new Set(concepts)];
  }

  analyzeQuestionIntent(text) {
    const intents = {
      definition: [
        "とは",
        "って何",
        "とはなんですか",
        "意味",
        "定義",
        "what is",
      ],
      example: ["例", "具体的", "サンプル", "実例", "どんな", "example"],
      howto: [
        "方法",
        "やり方",
        "どうやって",
        "手順",
        "使い方",
        "how to",
        "書き方",
      ],
      why: ["なぜ", "どうして", "理由", "わけ", "why"],
      difference: ["違い", "差", "比較", "vs", "対", "difference"],
      error: ["エラー", "うまくいかない", "動かない", "error", "バグ", "bug"],
    };

    const detected = [];
    const lowerText = text.toLowerCase();

    for (const [intent, keywords] of Object.entries(intents)) {
      for (const keyword of keywords) {
        if (lowerText.includes(keyword.toLowerCase())) {
          detected.push(intent);
          break;
        }
      }
    }

    return detected.length > 0 ? detected : ["general"];
  }

  updateFromOntology(ontology) {
    for (const [conceptId, concept] of ontology.concepts) {
      const keywords = [concept.label];
      if (concept.synonyms) {
        keywords.push(...concept.synonyms);
      }
      this.addConceptKeywords(conceptId, keywords);
    }
    console.log("📝 オントロジーからキーワードを更新しました");
  }

  addConceptKeywords(concept, keywords) {
    if (this.conceptKeywords.has(concept)) {
      const existing = this.conceptKeywords.get(concept);
      const uniqueKeywords = [...new Set([...existing, ...keywords])];
      this.conceptKeywords.set(concept, uniqueKeywords);
    } else {
      this.conceptKeywords.set(concept, keywords);
    }
  }

  analyzeText(text) {
    console.log("=== 概念抽出分析 ===");
    console.log("入力:", text.substring(0, 50) + "...");
    const concepts = this.extractConcepts(text);
    const intents = this.analyzeQuestionIntent(text);
    console.log("概念:", concepts);
    console.log("意図:", intents);
    return { concepts, intents };
  }
}
```

---

## STEP 4: 学習支援機能の実装

### **4-1. learning-support.js を作成**

`js/learning-support.js` を新規作成：

```javascript
// js/learning-support.js - 学習支援機能

class LearningSupport {
  constructor(ontology) {
    this.ontology = ontology;
    this.learnerProgress = new Map();
    this.currentHintLevels = new Map();
  }

  // ⭐ 前提知識チェック
  checkPrerequisites(conceptId, learnerKnowledge = []) {
    const prereqChain = this.ontology.getPrerequisiteChain(conceptId);

    const result = {
      conceptId: conceptId,
      conceptLabel: this.ontology.getConcept(conceptId)?.label || conceptId,
      allPrerequisites: prereqChain,
      missingPrerequisites: [],
      readyToLearn: true,
      recommendation: "",
    };

    for (const prereq of prereqChain) {
      if (!learnerKnowledge.includes(prereq.conceptId)) {
        result.missingPrerequisites.push(prereq);
        result.readyToLearn = false;
      }
    }

    if (!result.readyToLearn) {
      const missing = result.missingPrerequisites
        .map((p) => p.concept?.label || p.conceptId)
        .join("、");
      result.recommendation = `「${result.conceptLabel}」を学ぶ前に、まず「${missing}」を理解しましょう。`;
    } else {
      result.recommendation = `「${result.conceptLabel}」を学ぶ準備ができています！`;
    }

    return result;
  }

  // ⭐ 難易度適応型説明の生成
  generateAdaptiveExplanation(conceptId, learnerLevel = "beginner") {
    const concept = this.ontology.getConcept(conceptId);
    if (!concept) return null;

    const explanation = this.ontology.getExplanation(conceptId, learnerLevel);
    const misconceptions = this.ontology.getMisconceptions(conceptId);
    const exercises = this.ontology.getExercises(conceptId);
    const prereqs = this.ontology.getPrerequisiteChain(conceptId);

    return {
      concept: concept,
      level: learnerLevel,
      explanation: explanation.text,
      relatedMisconceptions: misconceptions.slice(0, 2),
      recommendedExercises: exercises.slice(0, 2),
      prerequisites: prereqs.map((p) => ({
        id: p.conceptId,
        label: p.concept?.label || p.conceptId,
      })),
      nextTopics: this.getNextTopics(conceptId),
    };
  }

  // ⭐ 段階的ヒントの生成
  getProgressiveHint(exerciseId) {
    const currentLevel = this.currentHintLevels.get(exerciseId) || 0;
    const hintInfo = this.ontology.getHint(exerciseId, currentLevel);

    if (hintInfo) {
      if (hintInfo.hasMoreHints) {
        this.currentHintLevels.set(exerciseId, currentLevel + 1);
      }
      return hintInfo;
    }

    return {
      hint: "これ以上のヒントはありません。もう一度問題を読み直してみましょう。",
      currentLevel: currentLevel,
      totalHints: 0,
      hasMoreHints: false,
    };
  }

  resetHint(exerciseId) {
    this.currentHintLevels.set(exerciseId, 0);
  }

  resetAllHints() {
    this.currentHintLevels.clear();
  }

  // ⭐ 次に学ぶべきトピックを推奨
  getNextTopics(currentConceptId) {
    const nextTopics = [];

    for (const [id, concept] of this.ontology.concepts) {
      if (
        concept.prerequisites &&
        concept.prerequisites.includes(currentConceptId)
      ) {
        nextTopics.push({
          id: id,
          label: concept.label,
          level: concept.level,
          reason: `「${
            this.ontology.getConcept(currentConceptId)?.label
          }」を理解したら次のステップ`,
        });
      }
    }

    return nextTopics;
  }

  // ⭐ よくある誤解への対応
  addressMisconception(conceptId, wrongBelief) {
    const misconceptions = this.ontology.getMisconceptions(conceptId);
    const lowerWrong = wrongBelief.toLowerCase();

    const matchingMisconception = misconceptions.find(
      (m) =>
        lowerWrong.includes(m.wrong.toLowerCase()) ||
        m.wrong.toLowerCase().includes(lowerWrong)
    );

    if (matchingMisconception) {
      return {
        found: true,
        misconception: matchingMisconception,
        response: `よくある誤解ですね！\n\n❌ 誤解: ${matchingMisconception.wrong}\n\n✅ 正しい理解: ${matchingMisconception.correct}\n\n💡 ヒント: ${matchingMisconception.hint}`,
      };
    }

    return {
      found: false,
      response: "その誤解についての情報は登録されていません。",
    };
  }

  // ⭐ 学習進捗の記録
  recordProgress(learnerId, conceptId, status) {
    if (!this.learnerProgress.has(learnerId)) {
      this.learnerProgress.set(learnerId, new Map());
    }

    const learnerData = this.learnerProgress.get(learnerId);
    learnerData.set(conceptId, {
      status: status,
      lastUpdated: new Date(),
      attempts: (learnerData.get(conceptId)?.attempts || 0) + 1,
    });
  }

  getProgress(learnerId) {
    const learnerData = this.learnerProgress.get(learnerId);
    if (!learnerData) return [];

    return Array.from(learnerData.entries()).map(([conceptId, data]) => ({
      conceptId,
      label: this.ontology.getConcept(conceptId)?.label || conceptId,
      ...data,
    }));
  }

  // ⭐ 学習パスの生成
  generateLearningPath(targetConceptId, learnerKnowledge = []) {
    const path = [];
    const prereqCheck = this.checkPrerequisites(
      targetConceptId,
      learnerKnowledge
    );

    for (const prereq of prereqCheck.missingPrerequisites) {
      if (!path.find((p) => p.conceptId === prereq.conceptId)) {
        path.push({
          conceptId: prereq.conceptId,
          label: prereq.concept?.label || prereq.conceptId,
          reason: "前提知識",
          order: prereq.depth,
        });
      }
    }

    path.push({
      conceptId: targetConceptId,
      label:
        this.ontology.getConcept(targetConceptId)?.label || targetConceptId,
      reason: "学習目標",
      order: 0,
    });

    return path.sort((a, b) => b.order - a.order);
  }
}
```

---

## STEP 5: ハイブリッド検索の実装

### **5-1. なぜハイブリッド検索が必要か？**

```
【ベクトル検索の得意・不得意】
✅ 得意: 意味的に似た表現を見つける
  「繰り返し処理」→「ループ」を見つけられる
❌ 不得意: 専門用語の完全一致
  「useState」→ 正確にマッチしにくい

【BM25（キーワード検索）の得意・不得意】
✅ 得意: 専門用語の完全一致
  「useState」→ 正確にマッチ
❌ 不得意: 意味的な類似
  「繰り返し」→「ループ」を見つけられない

【ハイブリッド検索】
両方の長所を組み合わせる！
ハイブリッドスコア = ベクトル類似度 × 0.6 + BM25スコア × 0.4
```

### **5-2. hybrid-search.js を作成**

`js/hybrid-search.js` を新規作成：

```javascript
// js/hybrid-search.js - ベクトル検索 + BM25 ハイブリッド検索

class HybridSearchEngine {
  constructor() {
    this.documents = [];
    this.embeddings = [];
    this.llm = new EducationLLMClient(API_CONFIG.studentId);

    this.k1 = 1.5;
    this.b = 0.75;
    this.avgDocLength = 0;
    this.idf = new Map();
  }

  async addDocument(text, metadata = {}) {
    try {
      const embedding = await this.llm.getEmbedding(text);
      const docId = this.documents.length;
      const tokens = this.tokenize(text);

      this.documents.push({
        id: docId,
        text: text,
        tokens: tokens,
        tokenCount: tokens.length,
        metadata: metadata,
      });
      this.embeddings.push(embedding);
      this.updateBM25Stats();

      return docId;
    } catch (error) {
      console.error("文書追加エラー:", error);
      throw error;
    }
  }

  tokenize(text) {
    const tokens = text
      .toLowerCase()
      .replace(/[、。！？「」『』（）\[\]{},.!?()]/g, " ")
      .split(/\s+/)
      .filter((token) => token.length > 0);

    const additionalTokens = [];
    for (const token of tokens) {
      if (/[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(token)) {
        for (let i = 0; i < token.length - 1; i++) {
          additionalTokens.push(token.substring(i, i + 2));
        }
      }
    }

    return [...tokens, ...additionalTokens];
  }

  updateBM25Stats() {
    const totalLength = this.documents.reduce(
      (sum, doc) => sum + doc.tokenCount,
      0
    );
    this.avgDocLength = totalLength / this.documents.length || 0;

    const termDocFreq = new Map();

    for (const doc of this.documents) {
      const uniqueTokens = new Set(doc.tokens);
      for (const token of uniqueTokens) {
        termDocFreq.set(token, (termDocFreq.get(token) || 0) + 1);
      }
    }

    const N = this.documents.length;
    for (const [term, df] of termDocFreq) {
      this.idf.set(term, Math.log((N - df + 0.5) / (df + 0.5)));
    }
  }

  calculateBM25Score(queryTokens, docId) {
    const doc = this.documents[docId];
    if (!doc) return 0;

    let score = 0;
    const docLength = doc.tokenCount;
    const termFreq = new Map();

    for (const token of doc.tokens) {
      termFreq.set(token, (termFreq.get(token) || 0) + 1);
    }

    for (const queryTerm of queryTokens) {
      const tf = termFreq.get(queryTerm) || 0;
      const idfValue = this.idf.get(queryTerm) || 0;

      const numerator = tf * (this.k1 + 1);
      const denominator =
        tf + this.k1 * (1 - this.b + this.b * (docLength / this.avgDocLength));

      score += idfValue * (numerator / denominator);
    }

    return score;
  }

  cosineSimilarity(vectorA, vectorB) {
    if (!vectorA || !vectorB || vectorA.length !== vectorB.length) return 0;

    const dotProduct = vectorA.reduce((sum, a, i) => sum + a * vectorB[i], 0);
    const normA = Math.sqrt(vectorA.reduce((sum, a) => sum + a * a, 0));
    const normB = Math.sqrt(vectorB.reduce((sum, b) => sum + b * b, 0));

    return dotProduct / (normA * normB);
  }

  async search(query, topK = 5, options = {}) {
    if (this.documents.length === 0) return [];

    const { vectorWeight = 0.6, bm25Weight = 0.4 } = options;

    try {
      const queryEmbedding = await this.llm.getEmbedding(query);
      const queryTokens = this.tokenize(query);

      const results = this.documents.map((doc, idx) => {
        const vectorScore = this.cosineSimilarity(
          queryEmbedding,
          this.embeddings[idx]
        );
        const bm25RawScore = this.calculateBM25Score(queryTokens, idx);

        return {
          docId: idx,
          document: doc,
          vectorScore: vectorScore,
          bm25Score: bm25RawScore,
          similarity: vectorScore,
        };
      });

      const maxBM25 = Math.max(...results.map((r) => r.bm25Score), 0.001);
      results.forEach((r) => {
        r.bm25ScoreNormalized = r.bm25Score / maxBM25;
        r.hybridScore =
          r.vectorScore * vectorWeight + r.bm25ScoreNormalized * bm25Weight;
        r.similarity = r.hybridScore;
      });

      results.sort((a, b) => b.hybridScore - a.hybridScore);
      console.log(
        `🔍 ハイブリッド検索 (ベクトル:${vectorWeight * 100}%, BM25:${
          bm25Weight * 100
        }%)`
      );

      return results.slice(0, topK);
    } catch (error) {
      console.error("ハイブリッド検索エラー:", error);
      throw error;
    }
  }

  async vectorSearchOnly(query, topK = 5) {
    if (this.documents.length === 0) return [];

    const queryEmbedding = await this.llm.getEmbedding(query);

    const results = this.documents.map((doc, idx) => ({
      docId: idx,
      document: doc,
      similarity: this.cosineSimilarity(queryEmbedding, this.embeddings[idx]),
    }));

    results.sort((a, b) => b.similarity - a.similarity);
    return results.slice(0, topK);
  }

  bm25SearchOnly(query, topK = 5) {
    if (this.documents.length === 0) return [];

    const queryTokens = this.tokenize(query);

    const results = this.documents.map((doc, idx) => ({
      docId: idx,
      document: doc,
      similarity: this.calculateBM25Score(queryTokens, idx),
    }));

    const maxScore = Math.max(...results.map((r) => r.similarity), 0.001);
    results.forEach((r) => (r.similarity = r.similarity / maxScore));

    results.sort((a, b) => b.similarity - a.similarity);
    return results.slice(0, topK);
  }
}
```

### **5-3. semantic-rag.js を作成**

`js/semantic-rag.js` を新規作成：

```javascript
// js/semantic-rag.js - 学習支援セマンティックRAGシステム

class SemanticRAGSystem {
  constructor() {
    this.searchEngine = new HybridSearchEngine();
    this.llm = new EducationLLMClient(API_CONFIG.studentId);
    this.ontology = new LearningOntology();
    this.conceptExtractor = new ConceptExtractor();
    this.learningSupport = null;
    this.initialized = false;
  }

  async initialize(documents, ontologyData) {
    console.log("🚀 学習支援セマンティックRAGシステム初期化中...");

    try {
      await this.ontology.loadOntology(ontologyData);
      this.conceptExtractor.updateFromOntology(this.ontology);
      this.learningSupport = new LearningSupport(this.ontology);

      console.log("📄 文書をインデックス化中...");
      for (const doc of documents) {
        await this.searchEngine.addDocument(doc.content, doc);
      }
      console.log(`✅ ${documents.length}件の文書を登録完了`);

      this.initialized = true;
      console.log("✅ 学習支援セマンティックRAGシステム準備完了！");
    } catch (error) {
      console.error("❌ 初期化エラー:", error);
      throw error;
    }
  }

  async expandQuery(query) {
    console.log("🔍 クエリを拡張中:", query);

    const concepts = this.conceptExtractor.extractConcepts(query);
    const intents = this.conceptExtractor.analyzeQuestionIntent(query);
    console.log("抽出された概念:", concepts);

    const expandedConcepts = new Set(concepts);
    const synonyms = [];

    for (const concept of concepts) {
      const relatedConcepts = this.ontology.findRelatedConcepts(concept, 1);
      relatedConcepts.forEach((c) => expandedConcepts.add(c));

      const prerequisites = this.ontology.getPrerequisiteChain(concept);
      prerequisites.forEach((p) => expandedConcepts.add(p.conceptId));

      synonyms.push(...this.ontology.getSynonyms(concept));
    }

    const expandedQuery = this.buildExpandedQuery(
      query,
      expandedConcepts,
      synonyms
    );

    return {
      original: query,
      concepts: Array.from(concepts),
      intents: intents,
      expandedConcepts: Array.from(expandedConcepts),
      synonyms: synonyms,
      expandedQuery: expandedQuery,
    };
  }

  buildExpandedQuery(originalQuery, concepts, synonyms) {
    const conceptLabels = Array.from(concepts)
      .map((c) => this.ontology.getConcept(c))
      .filter((c) => c !== undefined)
      .map((c) => c.label);

    const allTerms = [...new Set([...conceptLabels, ...synonyms])];
    return `${originalQuery} ${allTerms.join(" ")}`;
  }

  async semanticQuery(question, options = {}) {
    if (!this.initialized) {
      throw new Error("システムが初期化されていません");
    }

    console.log("\n=== 学習支援セマンティック検索開始 ===");
    console.log("質問:", question);

    try {
      const expandedQuery = await this.expandQuery(question);

      const relevantDocs = await this.searchEngine.search(
        expandedQuery.expandedQuery,
        options.retrieveCount || 5,
        { vectorWeight: 0.6, bm25Weight: 0.4 }
      );

      const rerankedDocs = this.rerankWithOntology(
        relevantDocs,
        expandedQuery.concepts
      );
      const learningInfo = this.collectLearningInfo(expandedQuery);

      const context = this.buildLearningContext(
        rerankedDocs.slice(0, 3),
        expandedQuery,
        learningInfo
      );
      const prompt = this.buildLearningPrompt(
        question,
        context,
        expandedQuery,
        learningInfo,
        options.learnerLevel
      );

      console.log("🤖 LLMで回答生成中...");
      const response = await this.llm.chat(prompt, options);

      return {
        answer: response.response,
        originalQuery: question,
        expandedQuery: expandedQuery,
        sources: rerankedDocs.slice(0, 3),
        conceptsUsed: expandedQuery.expandedConcepts,
        learningInfo: learningInfo,
        usage: response.usage,
      };
    } catch (error) {
      console.error("❌ セマンティック検索エラー:", error);
      throw error;
    }
  }

  rerankWithOntology(documents, queryConcepts) {
    return documents
      .map((doc) => {
        const docConcepts = this.conceptExtractor.extractConcepts(
          doc.document.text
        );
        const semanticScore = this.calculateSemanticRelevance(
          queryConcepts,
          docConcepts
        );

        return {
          ...doc,
          semanticScore: semanticScore,
          combinedScore:
            (doc.hybridScore || doc.similarity) * 0.7 + semanticScore * 0.3,
          docConcepts: docConcepts,
        };
      })
      .sort((a, b) => b.combinedScore - a.combinedScore);
  }

  calculateSemanticRelevance(queryConcepts, docConcepts) {
    let relevanceScore = 0;

    for (const queryConcept of queryConcepts) {
      for (const docConcept of docConcepts) {
        if (queryConcept === docConcept) {
          relevanceScore += 1.0;
        } else {
          const relatedConcepts = this.ontology.findRelatedConcepts(
            queryConcept,
            1
          );
          if (relatedConcepts.includes(docConcept)) {
            relevanceScore += 0.5;
          }
        }
      }
    }

    return Math.min(1.0, relevanceScore / Math.max(queryConcepts.length, 1));
  }

  collectLearningInfo(expandedQuery) {
    const info = {
      misconceptions: [],
      exercises: [],
      prerequisites: [],
      nextTopics: [],
      explanations: {},
    };

    for (const conceptId of expandedQuery.concepts) {
      const misconceptions = this.ontology.getMisconceptions(conceptId);
      info.misconceptions.push(...misconceptions.slice(0, 1));

      const exercises = this.ontology.getExercises(conceptId);
      info.exercises.push(...exercises.slice(0, 1));

      const prereqs = this.ontology.getPrerequisiteChain(conceptId);
      info.prerequisites.push(...prereqs);

      const nextTopics = this.learningSupport.getNextTopics(conceptId);
      info.nextTopics.push(...nextTopics);

      info.explanations[conceptId] = {
        beginner: this.ontology.getExplanation(conceptId, "beginner"),
        intermediate: this.ontology.getExplanation(conceptId, "intermediate"),
        advanced: this.ontology.getExplanation(conceptId, "advanced"),
      };
    }

    return info;
  }

  buildLearningContext(rerankedDocs, expandedQuery, learningInfo) {
    let context = "【参考文書】\n\n";

    rerankedDocs.forEach((doc, index) => {
      context += `[文書${index + 1}]\n${doc.document.text}\n\n`;
    });

    if (learningInfo.misconceptions.length > 0) {
      context += "\n【よくある誤解に注意】\n";
      learningInfo.misconceptions.forEach((m) => {
        context += `• ${m.wrong} → ${m.correct}\n`;
      });
    }

    context += `\n検索で使用された概念: ${expandedQuery.expandedConcepts.join(
      ", "
    )}`;

    return context;
  }

  buildLearningPrompt(
    question,
    context,
    expandedQuery,
    learningInfo,
    learnerLevel = "beginner"
  ) {
    const intentDescription = {
      definition: "定義や意味の説明",
      example: "具体例",
      howto: "方法や手順",
      why: "理由の説明",
      difference: "違いや比較",
      error: "エラーの解決",
      general: "一般的な情報",
    };

    const intents = expandedQuery.intents
      .map((i) => intentDescription[i] || i)
      .join("、");

    const levelGuide = {
      beginner:
        "初心者向けに、具体例や比喩を使って分かりやすく説明してください。専門用語は避けるか、使う場合は説明を添えてください。",
      intermediate:
        "基礎は理解している学習者向けに、技術的な詳細も含めて説明してください。",
      advanced:
        "深い理解を持つ学習者向けに、理論的背景や応用例も含めて説明してください。",
    };

    return `あなたは親切な学習支援AIです。学習者の理解を深めるために回答してください。

${context}

【学習者のレベル】
${learnerLevel}: ${levelGuide[learnerLevel] || levelGuide.beginner}

【学習者の質問意図】
${intents}

【質問】
${question}

【回答の指針】
1. 学習者のレベルと質問意図に合わせて回答してください
2. 必要に応じて具体例を含めてください
3. よくある誤解があれば注意を促してください
4. 理解を確認する簡単な問いかけで締めくくってください

回答:`;
  }

  displayRAGResult(result) {
    const container = document.getElementById("semantic-result");
    if (!container) return;

    let html = `
            <div class="learning-answer">
                <h3>🤖 AI回答:</h3>
                <div class="answer-text">${this.formatAnswer(
                  result.answer
                )}</div>

                <div class="search-info">
                    <h4>🔍 検索情報:</h4>
                    <ul>
                        <li><strong>元の質問:</strong> ${
                          result.originalQuery
                        }</li>
                        <li><strong>抽出された概念:</strong> ${
                          result.expandedQuery.concepts.join(", ") || "なし"
                        }</li>
                        <li><strong>質問の意図:</strong> ${result.expandedQuery.intents.join(
                          ", "
                        )}</li>
                    </ul>
                </div>

                <div class="sources">
                    <h4>📚 参考文書:</h4>
        `;

    result.sources.forEach((source, index) => {
      const hybridPercent = (
        (source.hybridScore || source.similarity) * 100
      ).toFixed(1);
      const vectorPercent = ((source.vectorScore || 0) * 100).toFixed(1);
      const bm25Percent = ((source.bm25ScoreNormalized || 0) * 100).toFixed(1);

      html += `
                <div class="source-doc">
                    <strong>文書${index + 1}</strong>
                    <span class="scores">
                        (総合: ${hybridPercent}%, ベクトル: ${vectorPercent}%, BM25: ${bm25Percent}%)
                    </span>
                    <p>${source.document.text.substring(0, 150)}...</p>
                </div>
            `;
    });

    html += "</div>";

    if (result.learningInfo) {
      if (result.learningInfo.misconceptions.length > 0) {
        html += `<div class="misconceptions"><h4>⚠️ よくある誤解:</h4>`;
        result.learningInfo.misconceptions.forEach((m) => {
          html += `
                        <div class="misconception-item">
                            <p><strong>❌ 誤解:</strong> ${m.wrong}</p>
                            <p><strong>✅ 正解:</strong> ${m.correct}</p>
                            <p><strong>💡 ヒント:</strong> ${m.hint}</p>
                        </div>
                    `;
        });
        html += "</div>";
      }

      if (result.learningInfo.exercises.length > 0) {
        html += `<div class="exercises"><h4>📝 確認問題:</h4>`;
        result.learningInfo.exercises.forEach((ex) => {
          html += `
                        <div class="exercise-item" data-exercise-id="${ex.id}">
                            <p><strong>Q:</strong> ${ex.question}</p>
                            <button class="hint-btn" onclick="showHint('${ex.id}')">💡 ヒントを見る</button>
                            <div class="hint-area" id="hint-${ex.id}"></div>
                        </div>
                    `;
        });
        html += "</div>";
      }

      if (result.learningInfo.nextTopics.length > 0) {
        html += `<div class="next-topics"><h4>📈 次に学ぶといい概念:</h4><ul>`;
        result.learningInfo.nextTopics.slice(0, 3).forEach((topic) => {
          html += `<li>${topic.label} - ${topic.reason}</li>`;
        });
        html += "</ul></div>";
      }
    }

    html += `
            <div class="usage">
                <small>使用トークン: ${
                  result.usage?.total_tokens || "-"
                }</small>
            </div>
        </div>`;

    container.innerHTML = html;
  }

  formatAnswer(text) {
    return text.replace(/\n/g, "<br>");
  }
}
```

---

## STEP 6-7: 学習支援 UI の実装

### **6-1. learning-rag.html を作成**

プロジェクトのルートに `learning-rag.html` を作成：

```html
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>学習支援RAGシステム</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: "Segoe UI", "Hiragino Sans", sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
        display: grid;
        grid-template-columns: 1fr 300px;
        gap: 20px;
      }
      .main-panel {
        background: white;
        border-radius: 15px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        padding: 30px;
      }
      .sidebar {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      .sidebar-card {
        background: white;
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
      }
      h1 {
        color: #667eea;
        margin-bottom: 10px;
        font-size: 1.8em;
      }
      .subtitle {
        color: #666;
        margin-bottom: 25px;
        font-size: 0.9em;
      }
      .input-section {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
      }
      #question-input {
        flex: 1;
        padding: 15px;
        border: 2px solid #ddd;
        border-radius: 8px;
        font-size: 16px;
      }
      #question-input:focus {
        outline: none;
        border-color: #667eea;
      }
      .btn {
        padding: 15px 25px;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s;
      }
      .btn-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }
      .btn-secondary {
        background: #f0f0f0;
        color: #333;
      }
      .btn:hover {
        transform: translateY(-2px);
      }
      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .level-selector {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
      }
      .level-btn {
        padding: 8px 16px;
        border: 2px solid #ddd;
        border-radius: 20px;
        background: white;
        cursor: pointer;
      }
      .level-btn.active {
        border-color: #667eea;
        background: #667eea;
        color: white;
      }
      .status {
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        display: none;
      }
      .status.loading {
        background: #e3f2fd;
        color: #1976d2;
        display: block;
      }
      .status.error {
        background: #ffebee;
        color: #c62828;
        display: block;
      }
      .status.success {
        background: #e8f5e9;
        color: #2e7d32;
        display: block;
      }
      .learning-answer {
        background: #f9f9f9;
        padding: 20px;
        border-radius: 10px;
        border-left: 5px solid #667eea;
      }
      .learning-answer h3,
      .learning-answer h4 {
        color: #667eea;
        margin: 15px 0 10px;
      }
      .learning-answer h3 {
        margin-top: 0;
      }
      .answer-text {
        line-height: 1.8;
        color: #333;
        padding: 15px;
        background: white;
        border-radius: 8px;
      }
      .source-doc {
        margin: 10px 0;
        padding: 15px;
        background: white;
        border-radius: 8px;
        border-left: 4px solid #2196f3;
      }
      .source-doc .scores {
        color: #666;
        font-size: 0.85em;
        margin-left: 10px;
      }
      .misconception-item {
        margin: 10px 0;
        padding: 15px;
        background: #fff3e0;
        border-radius: 8px;
        border-left: 4px solid #ff9800;
      }
      .exercise-item {
        margin: 10px 0;
        padding: 15px;
        background: #e8f5e9;
        border-radius: 8px;
        border-left: 4px solid #4caf50;
      }
      .hint-btn {
        padding: 8px 16px;
        background: #4caf50;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        margin-top: 10px;
      }
      .hint-area {
        margin-top: 10px;
        padding: 10px;
        background: #f5f5f5;
        border-radius: 5px;
        display: none;
      }
      .hint-area.show {
        display: block;
      }
      .next-topics ul {
        list-style: none;
        padding: 0;
      }
      .next-topics li {
        padding: 8px 15px;
        background: #e3f2fd;
        margin: 5px 0;
        border-radius: 5px;
      }
      .progress-title {
        font-size: 1.1em;
        font-weight: bold;
        color: #333;
        margin-bottom: 15px;
      }
      .concept-progress {
        margin: 8px 0;
      }
      .concept-name {
        font-size: 0.9em;
        color: #555;
        margin-bottom: 5px;
      }
      .progress-bar {
        width: 100%;
        height: 8px;
        background: #e0e0e0;
        border-radius: 4px;
        overflow: hidden;
      }
      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea, #764ba2);
      }
      .topic-tag {
        display: inline-block;
        padding: 5px 12px;
        background: #e3f2fd;
        color: #1976d2;
        border-radius: 15px;
        font-size: 0.85em;
        margin: 3px;
        cursor: pointer;
      }
      .topic-tag:hover {
        background: #bbdefb;
      }
      @media (max-width: 900px) {
        .container {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="main-panel">
        <h1>📚 学習支援RAGシステム</h1>
        <p class="subtitle">
          オントロジー強化 × ハイブリッド検索 × 適応型学習支援
        </p>

        <div class="status" id="status"></div>

        <div class="level-selector">
          <span style="margin-right: 10px; color: #666;">学習レベル:</span>
          <button
            class="level-btn active"
            data-level="beginner"
            onclick="setLevel('beginner')"
          >
            🌱 初級
          </button>
          <button
            class="level-btn"
            data-level="intermediate"
            onclick="setLevel('intermediate')"
          >
            🌿 中級
          </button>
          <button
            class="level-btn"
            data-level="advanced"
            onclick="setLevel('advanced')"
          >
            🌳 上級
          </button>
        </div>

        <div class="input-section">
          <input
            type="text"
            id="question-input"
            placeholder="質問を入力（例: 変数とは何ですか？）"
            disabled
          />
          <button
            class="btn btn-primary"
            id="ask-btn"
            onclick="askSemantic()"
            disabled
          >
            🔍 質問
          </button>
          <button class="btn btn-secondary" onclick="compareSearchModes()">
            ⚖️ 比較
          </button>
        </div>

        <div id="semantic-result"></div>
      </div>

      <div class="sidebar">
        <div class="sidebar-card">
          <div class="progress-title">📊 学習進捗</div>
          <div id="progress-display">
            <p style="color: #999;">質問を始めると表示されます</p>
          </div>
        </div>
        <div class="sidebar-card">
          <div class="progress-title">💡 推奨トピック</div>
          <div id="recommended-topics">
            <span class="topic-tag" onclick="askAbout('変数')">変数</span>
            <span class="topic-tag" onclick="askAbout('関数')">関数</span>
            <span class="topic-tag" onclick="askAbout('ループ')">ループ</span>
            <span class="topic-tag" onclick="askAbout('配列')">配列</span>
          </div>
        </div>
      </div>
    </div>

    <script src="js/config.js"></script>
    <script src="js/llm-client.js"></script>
    <script src="js/vector-search.js"></script>
    <script src="js/ontology.js"></script>
    <script src="js/concept-extractor.js"></script>
    <script src="js/learning-support.js"></script>
    <script src="js/hybrid-search.js"></script>
    <script src="js/semantic-rag.js"></script>

    <script>
      let semanticRAG;
      let currentLevel = "beginner";
      let conceptProgress = new Map();

      function showStatus(message, type = "loading") {
        const status = document.getElementById("status");
        status.textContent = message;
        status.className = "status " + type;
      }

      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showStatus("🚀 システムを初期化中...", "loading");

          const [documentsRes, ontologyRes] = await Promise.all([
            fetch("data/sample-documents.json"),
            fetch("data/learning-ontology.json"),
          ]);

          const documentsData = await documentsRes.json();
          const ontologyData = await ontologyRes.json();

          semanticRAG = new SemanticRAGSystem();
          await semanticRAG.initialize(documentsData.documents, ontologyData);

          document.getElementById("question-input").disabled = false;
          document.getElementById("ask-btn").disabled = false;

          showStatus("✅ 準備完了！質問を入力してください", "success");
          setTimeout(() => {
            document.getElementById("status").style.display = "none";
          }, 3000);
        } catch (error) {
          console.error("初期化エラー:", error);
          showStatus("❌ エラー: " + error.message, "error");
        }
      });

      function setLevel(level) {
        currentLevel = level;
        document.querySelectorAll(".level-btn").forEach((btn) => {
          btn.classList.toggle("active", btn.dataset.level === level);
        });
      }

      async function askSemantic() {
        const input = document.getElementById("question-input");
        const question = input.value.trim();
        if (!question) {
          alert("質問を入力してください");
          return;
        }

        try {
          showStatus("🔍 検索中...", "loading");
          document.getElementById("ask-btn").disabled = true;

          const result = await semanticRAG.semanticQuery(question, {
            retrieveCount: 5,
            learnerLevel: currentLevel,
          });

          semanticRAG.displayRAGResult(result);
          updateProgress(result);
          document.getElementById("status").style.display = "none";
        } catch (error) {
          console.error("検索エラー:", error);
          showStatus("❌ エラーが発生しました", "error");
        } finally {
          document.getElementById("ask-btn").disabled = false;
        }
      }

      function askAbout(topic) {
        document.getElementById(
          "question-input"
        ).value = `${topic}とは何ですか？`;
        askSemantic();
      }

      function updateProgress(result) {
        if (!result.expandedQuery?.concepts) return;
        for (const concept of result.expandedQuery.concepts) {
          const current = conceptProgress.get(concept) || 0;
          conceptProgress.set(concept, Math.min(100, current + 20));
        }
        displayProgress();
      }

      function displayProgress() {
        const container = document.getElementById("progress-display");
        if (conceptProgress.size === 0) {
          container.innerHTML =
            '<p style="color: #999;">質問を始めると表示されます</p>';
          return;
        }
        let html = "";
        for (const [concept, progress] of conceptProgress) {
          const label =
            semanticRAG.ontology.getConcept(concept)?.label || concept;
          html += `<div class="concept-progress"><div class="concept-name">${label}</div><div class="progress-bar"><div class="progress-fill" style="width: ${progress}%"></div></div></div>`;
        }
        container.innerHTML = html;
      }

      function showHint(exerciseId) {
        const hintArea = document.getElementById(`hint-${exerciseId}`);
        const hintInfo =
          semanticRAG.learningSupport.getProgressiveHint(exerciseId);
        hintArea.innerHTML = `<strong>💡 ヒント ${hintInfo.currentLevel + 1}/${
          hintInfo.totalHints
        }:</strong><p>${hintInfo.hint}</p>${
          hintInfo.hasMoreHints
            ? "<small>もう一度クリックで次のヒント</small>"
            : ""
        }`;
        hintArea.classList.add("show");
      }

      async function compareSearchModes() {
        const question = document.getElementById("question-input").value.trim();
        if (!question) {
          alert("まず質問を入力してください");
          return;
        }

        try {
          showStatus("⚖️ 検索モードを比較中...", "loading");
          const [vectorResults, bm25Results, hybridResults] = await Promise.all(
            [
              semanticRAG.searchEngine.vectorSearchOnly(question, 3),
              Promise.resolve(
                semanticRAG.searchEngine.bm25SearchOnly(question, 3)
              ),
              semanticRAG.searchEngine.search(question, 3),
            ]
          );

          document.getElementById("semantic-result").innerHTML = `
                    <div class="learning-answer">
                        <h3>⚖️ 検索モード比較: "${question}"</h3>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-top: 20px;">
                            <div style="background: #e3f2fd; padding: 15px; border-radius: 8px;">
                                <h4 style="color: #1976d2;">ベクトル検索</h4>
                                ${vectorResults
                                  .map(
                                    (r, i) =>
                                      `<p style="font-size: 0.85em;">${
                                        i + 1
                                      }. ${r.document.text.substring(
                                        0,
                                        50
                                      )}...<br><small>${(
                                        r.similarity * 100
                                      ).toFixed(1)}%</small></p>`
                                  )
                                  .join("")}
                            </div>
                            <div style="background: #fff3e0; padding: 15px; border-radius: 8px;">
                                <h4 style="color: #f57c00;">BM25検索</h4>
                                ${bm25Results
                                  .map(
                                    (r, i) =>
                                      `<p style="font-size: 0.85em;">${
                                        i + 1
                                      }. ${r.document.text.substring(
                                        0,
                                        50
                                      )}...<br><small>${(
                                        r.similarity * 100
                                      ).toFixed(1)}%</small></p>`
                                  )
                                  .join("")}
                            </div>
                            <div style="background: #e8f5e9; padding: 15px; border-radius: 8px;">
                                <h4 style="color: #388e3c;">ハイブリッド</h4>
                                ${hybridResults
                                  .map(
                                    (r, i) =>
                                      `<p style="font-size: 0.85em;">${
                                        i + 1
                                      }. ${r.document.text.substring(
                                        0,
                                        50
                                      )}...<br><small>${(
                                        r.hybridScore * 100
                                      ).toFixed(1)}%</small></p>`
                                  )
                                  .join("")}
                            </div>
                        </div>
                    </div>`;
          document.getElementById("status").style.display = "none";
        } catch (error) {
          console.error("比較エラー:", error);
          showStatus("❌ エラー", "error");
        }
      }

      document
        .getElementById("question-input")
        .addEventListener("keypress", (e) => {
          if (e.key === "Enter" && !document.getElementById("ask-btn").disabled)
            askSemantic();
        });
    </script>
  </body>
</html>
```

---

## STEP 8: テスト対策 RAG の改善（発展課題）

基本実装が完了したら、**第 2 回で作成したテスト対策用 RAG**を今回の技術で改善しましょう。

### **8-1. 改善のポイント**

| 改善項目         | 第 2 回の RAG    | 今回の技術で改善                     |
| ---------------- | ---------------- | ------------------------------------ |
| **検索精度**     | ベクトル検索のみ | ハイブリッド検索（専門用語に強い）   |
| **クエリ拡張**   | なし             | オントロジーで関連概念・同義語も検索 |
| **説明の適応**   | 固定             | 学習レベルに応じた説明               |
| **よくある誤解** | なし             | 誤解と正しい理解を提示               |
| **学習パス**     | なし             | 前提知識のチェックと推奨             |

### **8-2. 改善手順ガイド**

#### **Step A: 自分の教科書の概念を洗い出す（10 分）**

まず、第 2 回で使った教科書やノートから、重要な概念を 5〜10 個洗い出します。

```
【例：情報系の場合】
・OS（オペレーティングシステム）
・プロセス
・スレッド
・メモリ管理
・ファイルシステム

【例：数学の場合】
・微分
・積分
・極限
・連続性
・導関数
```

#### **Step B: 概念間の関係を整理する（10 分）**

洗い出した概念の「前提知識」と「関連概念」を整理します。

```
【前提知識（prerequisite）の例】
積分 ← 微分 ← 極限
  ↑     ↑
「積分を理解するには微分が必要」
「微分を理解するには極限が必要」

【関連概念（related）の例】
微分 ↔ 導関数（ほぼ同じ概念）
OS ↔ カーネル（密接に関連）
```

#### **Step C: よくある誤解を考える（10 分）**

テストで間違えやすいポイントを「誤解」として整理します。

```
【例：微分の誤解】
❌ 誤解：「微分は傾きを求めること」
✅ 正解：「微分は瞬間の変化率を求めること。傾きはその一つの解釈」
💡 ヒント：「グラフがない関数でも微分は定義できる」

【例：プロセスの誤解】
❌ 誤解：「プロセスとプログラムは同じ」
✅ 正解：「プログラムは静的なコード、プロセスは実行中のインスタンス」
💡 ヒント：「同じプログラムから複数のプロセスが生まれることがある」
```

#### **Step D: オントロジーファイルを作成（15 分）**

`data/my-study-ontology.json` を新規作成：

```json
{
  "concepts": {
    "your-concept-1": {
      "label": "概念名（日本語）",
      "level": "beginner",
      "prerequisites": [],
      "relatedConcepts": [],
      "synonyms": ["別名1", "別名2"],
      "description": "この概念の一言説明",
      "explanations": {
        "beginner": "初心者向けの説明（具体例や比喩を使う）",
        "intermediate": "中級者向けの説明（技術用語を使ってOK）",
        "advanced": "上級者向けの説明（理論的背景を含む）"
      },
      "misconceptions": [
        {
          "wrong": "よくある誤解",
          "correct": "正しい理解",
          "hint": "理解のためのヒント"
        }
      ],
      "exercises": [
        {
          "id": "ex1",
          "question": "確認問題",
          "type": "short-answer",
          "answer": "答え",
          "hints": ["ヒント1", "ヒント2"]
        }
      ]
    }
  },
  "relations": [],
  "learnerLevels": {
    "beginner": { "description": "初学者" },
    "intermediate": { "description": "基礎理解済み" },
    "advanced": { "description": "応用段階" }
  }
}
```

#### **Step E: 改善版 RAG ページを作成（5 分）**

`my-study-rag.html` を作成し、初期化部分を変更：

```javascript
// 初期化部分を変更
const [documentsRes, ontologyRes] = await Promise.all([
  fetch("data/my-study-documents.json"), // ← 第2回の文書
  fetch("data/my-study-ontology.json"), // ← 自分用オントロジー
]);
```

#### **Step F: 改善効果を確認（10 分）**

以下の観点で第 2 回の RAG と今回の RAG を比較：

| テスト項目     | 確認方法                                       |
| -------------- | ---------------------------------------------- |
| **同義語検索** | 教科書の用語と違う言い方で質問してみる         |
| **専門用語**   | 略語や専門用語で検索してみる                   |
| **前提知識**   | 難しい概念を聞いて、前提知識が提示されるか確認 |
| **誤解対応**   | よくある誤解を含む質問をしてみる               |
| **レベル適応** | 学習レベルを変えて説明が変わるか確認           |

### **8-3. 改善のコツ**

```
【コツ1: 同義語を充実させる】
教科書によって用語が違うことが多い
例：「OS」「オペレーティングシステム」「基本ソフト」

【コツ2: 前提知識は控えめに】
あまり深く遡りすぎると学習パスが長くなりすぎる
直接の前提だけを指定するのが良い

【コツ3: 誤解は具体的に】
「〇〇と勘違いしやすい」ではなく
「〇〇だと思っている人が多いが、実は△△」と具体的に

【コツ4: 練習問題はシンプルに】
複雑な問題より、概念の理解を確認する簡単な問題が効果的
```

---

## STEP 9: 提出

### **9-1. GitHub にプッシュ**

```bash
git add .
git commit -m "第3回授業完了：学習支援オントロジーRAGシステム"
git push origin main
```

### **9-2. 学習レポート作成**

`第3回学習レポート.md` を作成：

```markdown
# 第 3 回学習レポート

**学生 ID**: student_XXX
**氏名**: ○○○○
**日付**: 2025 年 ○ 月 ○ 日

## 1. 知識ベース・オントロジーの理解

### 知識ベースとは

（自分の言葉で説明）

### オントロジーとは

（自分の言葉で説明）

### オントロジーと構造化 RAG の違い

（理解したことを記述）

### なぜ RAG にオントロジーが必要か

（3 つの問題と解決策を自分の言葉で）

## 2. 実装した機能

- [ ] オントロジークラス
- [ ] 概念抽出器
- [ ] 学習支援機能
- [ ] ハイブリッド検索
- [ ] 学習進捗 UI

## 3. ハイブリッド検索の効果

（ベクトル検索と BM25 の違い、ハイブリッドの利点を記述）

## 4. テスト対策 RAG の改善（実施した場合）

### 追加したオントロジー

- 概念数: ○ 個
- 主な概念: ○○、△△、□□

### 改善効果

（第 2 回と比べてどう良くなったか、具体例を含めて）

## 5. 質問・感想

（理解が不十分な点、感想など）
```

---

## 最終チェックリスト

### **必須**

- [ ] 知識ベース・オントロジーの概念を理解した
- [ ] オントロジーと構造化 RAG の違いを説明できる
- [ ] `js/ontology.js` が動作する
- [ ] `js/concept-extractor.js` が動作する
- [ ] `js/learning-support.js` が動作する
- [ ] `js/hybrid-search.js` が動作する
- [ ] `js/semantic-rag.js` が動作する
- [ ] `learning-rag.html` でシステムが動作する
- [ ] GitHub にプッシュ完了

### **発展（時間が余った場合）**

- [ ] 自分の教科書用オントロジーを作成
- [ ] 第 2 回のテスト対策 RAG を改善
- [ ] 改善効果を確認

---

## 参考：今日学んだ重要な概念

| 概念                 | 説明                                                         |
| -------------------- | ------------------------------------------------------------ |
| **知識ベース**       | コンピュータが利用できる形式で整理された知識の集まり         |
| **オントロジー**     | 概念とその関係性を形式的に定義したもの（設計図）             |
| **知識グラフ**       | オントロジーに基づいて具体的な事実を蓄積したもの（実データ） |
| **構造化 RAG**       | 構造化されたデータを検索・活用して LLM を強化する仕組み      |
| **前提知識チェーン** | ある概念を理解するために必要な知識の連鎖                     |
| **BM25**             | 用語頻度と文書頻度に基づくキーワード検索アルゴリズム         |
| **ハイブリッド検索** | ベクトル検索とキーワード検索を組み合わせた手法               |

---

**お疲れ様でした！🎉**
